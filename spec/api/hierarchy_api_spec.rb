=begin
Talis Blueprint API

This is the API documentation for [Blueprint](https://github.com/talis/blueprint-server), a primitive for institutional structure and time periods

OpenAPI spec version: 1.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git


=end

require 'spec_helper'
require 'json'

# Unit tests for BlueprintClient::HierarchyApi
# Automatically generated by swagger-codegen (github.com/swagger-api/swagger-codegen)
# Please update as you see appropriate
describe 'HierarchyApi' do
  before do
    # run before each test
    @instance = BlueprintClient::HierarchyApi.new
  end

  after do
    # run after each test
  end

  describe 'test an instance of HierarchyApi' do
    it 'should create an instact of HierarchyApi' do
      @instance.should be_a(BlueprintClient::HierarchyApi)
    end
  end

  # unit tests for add_node
  # 
  # Add a node
  # @param namespace_inc_global identifier namespacing the blueprint. `global` is a special namespace which references data from all blueprints in the call.
  # @param body node
  # @param [Hash] opts the optional parameters
  # @return [NodeBody]
  describe 'add_node test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

  # unit tests for bulk_upload
  # 
  # Send operations to modify nodes in bulk, to be applied/rejected as a single transaction.\nFormat will be:\n\n  OLD NODE TYPE, OLD NODE ID, NEW NODE TYPE, NEW NODE ID, PARENTS, TITLE, DESCRIPTION, DOMAIN IDS, STUDENT NUMBERS\n
  # @param namespace identifier namespacing the blueprint. It must start with a letter or underscore and can only be followed by letters, numbers and underscores.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe 'bulk_upload test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

  # unit tests for delete_node
  # 
  # Delete a node
  # @param namespace identifier namespacing the blueprint. It must start with a letter or underscore and can only be followed by letters, numbers and underscores.
  # @param id id identifying a domain model
  # @param type subtype of Node, e.g. &#39;modules&#39;, &#39;departments&#39;, etc.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe 'delete_node test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

  # unit tests for export_hierarchy
  # 
  # Download the blueprint&#39;s nodes in CSV format\nFormat will be:\n\n  OLD NODE TYPE, OLD NODE ID, NEW NODE TYPE, NEW NODE ID, PARENTS, TITLE, DESCRIPTION, DOMAIN IDS, STUDENT NUMBERS\n\nOLD NODE TYPE and OLD NODE ID are left intentionally blank to allow direct upload of the output back into the bulk importer\n
  # @param namespace identifier namespacing the blueprint. It must start with a letter or underscore and can only be followed by letters, numbers and underscores.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe 'export_hierarchy test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

  # unit tests for get_ancestors
  # Get ancestor nodes
  # A proxy for finding ancestors of a given node, equivalent to\n`/1/abc/nodes?filter[descendant]=department%2Fdep101`\n
  # @param id id identifying a domain model
  # @param namespace identifier namespacing the blueprint. It must start with a letter or underscore and can only be followed by letters, numbers and underscores.
  # @param type subtype of Node, e.g. &#39;modules&#39;, &#39;departments&#39;, etc.
  # @param [Hash] opts the optional parameters
  # @option opts [Float] :offset index to start result set from
  # @option opts [Float] :limit number of records to return
  # @return [NodeResultSet]
  describe 'get_ancestors test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

  # unit tests for get_children
  # Get child nodes
  # A proxy for finding children of a given node, equivalent to\n`/1/abc/nodes?filter[parent]=department%2Fdep101`\n
  # @param id id identifying a domain model
  # @param namespace identifier namespacing the blueprint. It must start with a letter or underscore and can only be followed by letters, numbers and underscores.
  # @param type subtype of Node, e.g. &#39;modules&#39;, &#39;departments&#39;, etc.
  # @param [Hash] opts the optional parameters
  # @option opts [Float] :offset index to start result set from
  # @option opts [Float] :limit number of records to return
  # @return [NodeResultSet]
  describe 'get_children test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

  # unit tests for get_descendants
  # Get descendant nodes
  # A proxy for finding descendants of a given node, equivalent to\n`/1/abc/nodes?filter[ancestor]=department%2Fdep101`\n
  # @param id id identifying a domain model
  # @param namespace identifier namespacing the blueprint. It must start with a letter or underscore and can only be followed by letters, numbers and underscores.
  # @param type subtype of Node, e.g. &#39;modules&#39;, &#39;departments&#39;, etc.
  # @param [Hash] opts the optional parameters
  # @option opts [Float] :offset index to start result set from
  # @option opts [Float] :limit number of records to return
  # @return [NodeResultSet]
  describe 'get_descendants test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

  # unit tests for get_node
  # 
  # Get details of a given node
  # @param namespace identifier namespacing the blueprint. It must start with a letter or underscore and can only be followed by letters, numbers and underscores.
  # @param id id identifying a domain model
  # @param type subtype of Node, e.g. &#39;modules&#39;, &#39;departments&#39;, etc.
  # @param [Hash] opts the optional parameters
  # @option opts [Array<String>] :include comma separated list of elements to hydrate. Can include children, parents, nodes, and/or assets
  # @return [NodeBody]
  describe 'get_node test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

  # unit tests for get_parents
  # Get parent nodes
  # A proxy for finding parents of a given node, equivalent to\n`/1/abc/nodes?filter[child]=department%2Fdep101`\n
  # @param id id identifying a domain model
  # @param namespace identifier namespacing the blueprint. It must start with a letter or underscore and can only be followed by letters, numbers and underscores.
  # @param type subtype of Node, e.g. &#39;modules&#39;, &#39;departments&#39;, etc.
  # @param [Hash] opts the optional parameters
  # @option opts [Float] :offset index to start result set from
  # @option opts [Float] :limit number of records to return
  # @return [NodeResultSet]
  describe 'get_parents test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

  # unit tests for replace_node
  # 
  # Replaces the node with the data sent in the body
  # @param namespace identifier namespacing the blueprint. It must start with a letter or underscore and can only be followed by letters, numbers and underscores.
  # @param id id identifying a domain model
  # @param body node
  # @param type subtype of Node, e.g. &#39;modules&#39;, &#39;departments&#39;, etc.
  # @param [Hash] opts the optional parameters
  # @return [NodeBody]
  describe 'replace_node test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

  # unit tests for search_nodes
  # Search nodes
  # This endpoint is a really flexible way to ask questions about the hierarchy.\nThe includes parameter can be set to either parents, children, assets.\n\nExamples:\n\n###### Find all nodes for abc:\n`/1/abc/nodes`\n\n###### Find all modules for abc:\n`/1/abc/nodes?filter[nodeType]=Modules`\n\n###### Find all nodes that are descendants of DEP101:\n`/1/abc/nodes?filter[descendant]=departments%2Fdep101`\n\n###### Find all nodes that are descendants of DEP101 or DEP102:\n`/1/abc/nodes?filter[descendant]=departments%2Fdep101,departments%2Fdep102`\n\n###### Find all nodes that are descendants of DEP101 and DEP102:\n`/1/abc/nodes?filter[descendant]=departments%2Fdep101&amp;filter[descendant]=departments%2Fdep102``\n\n###### Find all Departments that are ancestors of ABF203:\n`/1/abc/nodes?filter[descendant]=modules%2Fabf203&amp;filter[nodeType]=Departments` # &lt;= case insensitive\n\n###### Find all nodes with list assets that are descendants of DEP101 for abc:\n`/1/abc/nodes?filter[nodeType]=Modules&amp;filter[ancestor]=departments%2FDEP101&amp;filter[hasAssets]=true&amp;filter[assetType]=Lists`\n\n###### Globally, find all modules that have no list assets\n`/1/global/nodes?filter[nodeType]=Modules&amp;filter[hasAssets]=false&amp;filter[assetType]=Lists`\n\n###### Find all nodes of type modules during 2015 that have no assets. Note a node&#39;s valid_from/valid_to just need to overlap from/to to qualify\n`/1/global/nodes?filter[nodeType]=Modules&amp;filter[hasAssets]=false&amp;filter[from]=20150101&amp;filter[to]=20151231`\n\n###### Find all nodes of type modules with assets which are also related to DEP101.\n`/1/global/nodes?filter[nodeType]=Modules&amp;filter[asset.node]=departments%2Fdep101`\n
  # @param namespace_inc_global identifier namespacing the blueprint. `global` is a special namespace which references data from all blueprints in the call.
  # @param [Hash] opts the optional parameters
  # @option opts [Float] :offset index to start result set from
  # @option opts [Float] :limit number of records to return
  # @option opts [Array<String>] :include comma separated list of elements to hydrate. Can include children, parents, nodes, and/or assets
  # @option opts [Array<String>] :filter_asset limit to nodes that have an asset matching type/code
  # @option opts [Array<String>] :filter_node_type type of nodes to return
  # @option opts [Array<String>] :filter_child limit to nodes with children matching type/code
  # @option opts [Array<String>] :filter_parent limit to nodes with parent matching type/code
  # @option opts [Array<String>] :filter_ancestor limit to nodes with ancestor matching type/code
  # @option opts [Array<String>] :filter_descendant limit to nodes with descendant matching type/code
  # @option opts [BOOLEAN] :filter_has_assets limit to either nodes that have assets (true) nodes that have no assets (false) or omit to consider both nodes with and without assets
  # @option opts [Array<String>] :filter_asset_type type of asset to return. Depricated. This filters the results by asset type, but incorrectly only returns the assets of thay type. Use asset.type.2
  # @option opts [Array<String>] :filter_asset_type2 type of asset to return. Version 2. This filters the results by asset type, but returns all the assets associated with the result.
  # @option opts [Date] :filter_from limit to results valid after this date, format is  ISO8601 date
  # @option opts [Date] :filter_to limit to results valid before this date, format is  ISO8601
  # @option opts [String] :q_node query term(s) to search for nodes.  Allows wildcard searching with &#39;*&#39;
  # @option opts [String] :q_child query id/title terms to search for child nodes.  Allows wildcard searching with &#39;*&#39;
  # @option opts [String] :q_parent query id/title terms to search for parent nodes.  Allows wildcard searching with &#39;*&#39;
  # @option opts [String] :q_descendant query id/title terms to search for descendant nodes.  Allows wildcard searching with &#39;*&#39;
  # @option opts [String] :q_ancestor query id/title terms to search for ancestor nodes.  Allows wildcard searching with &#39;*&#39;
  # @option opts [Array<String>] :filter_asset_node limit to nodes that have an asset related to another node matching type/code
  # @return [NodeResultSet]
  describe 'search_nodes test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

  # unit tests for update_node
  # 
  # Perform a partial update of a node
  # @param namespace identifier namespacing the blueprint. It must start with a letter or underscore and can only be followed by letters, numbers and underscores.
  # @param id id identifying a domain model
  # @param body node
  # @param type subtype of Node, e.g. &#39;modules&#39;, &#39;departments&#39;, etc.
  # @param [Hash] opts the optional parameters
  # @return [NodeBody]
  describe 'update_node test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

end
