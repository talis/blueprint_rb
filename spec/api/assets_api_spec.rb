=begin
Talis Blueprint API

This is the API documentation for [Blueprint](https://github.com/talis/blueprint-server), a primitive for institutional structure and time periods

OpenAPI spec version: 1.0.0

Generated by: https://github.com/swagger-api/swagger-codegen.git


=end

require 'spec_helper'
require 'json'

# Unit tests for BlueprintClient::AssetsApi
# Automatically generated by swagger-codegen (github.com/swagger-api/swagger-codegen)
# Please update as you see appropriate
describe 'AssetsApi' do
  before do
    # run before each test
    @instance = BlueprintClient::AssetsApi.new
  end

  after do
    # run after each test
  end

  describe 'test an instance of AssetsApi' do
    it 'should create an instact of AssetsApi' do
      @instance.should be_a(BlueprintClient::AssetsApi)
    end
  end

  # unit tests for add_asset_to_node
  # 
  # Add an asset to the node.  Body must be empty.  Will upsert the asset if it doesn&#39;t exist
  # @param namespace identifier namespacing the blueprint. It must start with a letter or underscore and can only be followed by letters, numbers and underscores.
  # @param type subtype of Node, e.g. &#39;modules&#39;, &#39;departments&#39;, etc.
  # @param id id identifying a domain model
  # @param asset_type subtype of Asset, e.g. &#39;textbooks&#39;, &#39;digitisations&#39;, etc.
  # @param asset_id id of an asset
  # @param [Hash] opts the optional parameters
  # @return [AssetBody]
  describe 'add_asset_to_node test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

  # unit tests for delete_asset
  # 
  # Delete an Asset
  # @param namespace identifier namespacing the blueprint. It must start with a letter or underscore and can only be followed by letters, numbers and underscores.
  # @param asset_id id of an asset
  # @param asset_type subtype of Asset, e.g. &#39;textbooks&#39;, &#39;digitisations&#39;, etc.
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe 'delete_asset test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

  # unit tests for get_asset
  # 
  # Get details of a given asset
  # @param namespace identifier namespacing the blueprint. It must start with a letter or underscore and can only be followed by letters, numbers and underscores.
  # @param asset_type subtype of Asset, e.g. &#39;textbooks&#39;, &#39;digitisations&#39;, etc.
  # @param asset_id id of an asset
  # @param [Hash] opts the optional parameters
  # @return [AssetBody]
  describe 'get_asset test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

  # unit tests for get_assets_in_node
  # 
  # Get for assets in the relevant node
  # @param namespace identifier namespacing the blueprint. It must start with a letter or underscore and can only be followed by letters, numbers and underscores.
  # @param type subtype of Node, e.g. &#39;modules&#39;, &#39;departments&#39;, etc.
  # @param id id identifying a domain model
  # @param [Hash] opts the optional parameters
  # @option opts [Array<String>] :filter_asset_type type of asset to return. Depricated. This filters the results by asset type, but incorrectly only returns the assets of thay type. Use asset.type.2
  # @option opts [Float] :offset index to start result set from
  # @option opts [Float] :limit number of records to return
  # @return [AssetResultSet]
  describe 'get_assets_in_node test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

  # unit tests for remove_asset_from_node
  # 
  # Remove an asset from the relevant node
  # @param namespace identifier namespacing the blueprint. It must start with a letter or underscore and can only be followed by letters, numbers and underscores.
  # @param type subtype of Node, e.g. &#39;modules&#39;, &#39;departments&#39;, etc.
  # @param id id identifying a domain model
  # @param asset_type subtype of Asset, e.g. &#39;textbooks&#39;, &#39;digitisations&#39;, etc.
  # @param asset_id id of an asset
  # @param [Hash] opts the optional parameters
  # @return [nil]
  describe 'remove_asset_from_node test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

  # unit tests for replace_asset
  # Replaces the Asset with the data sent in the body
  # Wholesale replacement of Asset data: if you were to PUT to:\n  /1/{namespace}/assets/sometype/someid\n\nwith a body of:\n  { type: \&quot;someothertype\&quot;, id: \&quot;someotherid\&quot; }\n\nIt would change the Asset&#39;s path to:\n  /1/{namespace}/assets/someothertype/someotherid\n\nand\n  /1/{namespace}/assets/sometype/someid\nwould return a 404.\nIt would also update the assets associated with any node.\n
  # @param namespace identifier namespacing the blueprint. It must start with a letter or underscore and can only be followed by letters, numbers and underscores.
  # @param asset_id id of an asset
  # @param asset_type subtype of Asset, e.g. &#39;textbooks&#39;, &#39;digitisations&#39;, etc.
  # @param [Hash] opts the optional parameters
  # @option opts [AssetBody] :body asset
  # @return [AssetBody]
  describe 'replace_asset test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

  # unit tests for search_assets
  # Search assets
  # This endpoint provides a way to get assets as a pageable result set, based (optionally) on filters.\nThe include parameter can only be set to `nodes`\n\n###### Find all assets in namespace abc\n`/1/abc/assets`\n\n###### Find all lists for abc:\n`/1/abc/assets?filter[assetType]=lists`\n\n###### Find all assets that are related to a given node of DEP101:\n`/1/abc/assets?filter[node]=departments%2Fdep101`\n\n###### Find all assets that are related to both node DEP101 and DEP102:\n`/1/abc/assets?filter[node]=departments%2Fdep101&amp;filter[node]=departments%2Fdep102`\n\n###### Find all assets that are related to either node DEP101 and DEP102:\n`/1/abc/assets?filter[node]=departments%2Fdep101,departments%2Fdep102`\n
  # @param namespace identifier namespacing the blueprint. It must start with a letter or underscore and can only be followed by letters, numbers and underscores.
  # @param [Hash] opts the optional parameters
  # @option opts [Float] :offset index to start result set from
  # @option opts [Float] :limit number of records to return
  # @option opts [Array<String>] :include comma separated list of elements to hydrate. Can include children, parents, nodes, and/or assets
  # @option opts [Array<String>] :filter_node limit to assets that are related to a node matching type/code
  # @option opts [Array<String>] :filter_asset_type type of asset to return. Depricated. This filters the results by asset type, but incorrectly only returns the assets of thay type. Use asset.type.2
  # @return [AssetResultSet]
  describe 'search_assets test' do
    it "should work" do
      # assertion here
      # should be_a()
      # should be_nil
      # should ==
      # should_not ==
    end
  end

end
